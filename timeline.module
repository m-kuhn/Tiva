<?php
// $Id$

/**
 * @file
 * This is an tl outlining how a module can be used to define a new
 * node type.  In Drupal 7 we move most of what was once needed in this file
 * to the timeline.install file so that it can be managed efficiently.
 *
 * In previous versions of Drupal, "teaser" and "page" were node view modes.  In
 * Drupal 7 we can define custom view modes to let the node know how it should
 * return it's data.  This module declares a custom view mode called
 * "timeline_node_list".
 *
 * We no longer need an extra database table to store this content type's
 * information.
 *
 * Most node types that provide fields do not require any custom code for
 * the fields, as the fields system provides storage and access.
 *
 * See @link http://drupal.org/node/707832 Field API Tutorial @endlink
 *
 * See @link http://drupal.org/node/443536 Field API Handbook Page @endlink
 *
 * See @link field Field API documentation @endlink
 *
 * See @link field_timeline.install field_timeline.install @endlink
 *
 * Remember that most node types do not require any custom code, as one
 * simply creates them using the fields UI.
 */

define("TIMELINE_OK", 0);
define("TIMELINE_NO_IMG", 1);
define("TIMELINE_NO_CONNECTION", 2);

/*
 *
 */
function _ajax_check_url_callback ($form, $form_state) {
  $errors = array();
  $url = $form_state['values']['archive_url']['und'][0];
  // default supported extensions.
  // ToDo: make them configurable in admin display.
  $extensions = 'png gif jpg jpeg';
  $errors += timeline_validate_extensions($url, $extensions);
  $img_tag = '';

  if (empty($errors)) {
    $download = _timeline_download_image($url);
    $image = image_load($download['file']->uri);

    $variables = array(
      'style_name' => 'thumbnail',
      'path'       => $download['file']->uri,
      'alt'        => 'Image Preview',
      'title'      => 'Image Preview',
      'getsize'    => TRUE,
    );

    $img_tag = theme('image_style', $variables);
  }

  form_set_error('archive_url', implode('<br/>', $errors));
  return '<div id="url-check-div">' . $img_tag . '</div>';
}










/*
 * All the image download and saving stuff...
 */

function _get_preview_image($url) {
  $content = drupal_http_request($url);

  if ($content->data) {
    $newfile = file_save_data($content->data);
    $image = image_load($newfile->uri);
    image_scale($image, 100);
    
    $info = file_validate_is_image($newfile);
    if ($info[0]) {
      $retval['errno'] = TIMELINE_NO_IMG;
      $retval['errmsg'] = $info[0];
    }
  }
  else {
    $retval['errno'] = TIMELINE_NO_CONNECTION;
  }

  $file = drupal_http_request($url);
  if ($file) {
    $image = image_load($file);
    image_scale($image, 100);
  }

}

/*
 *
 */

function _timeline_download_image($url) {
  global $user;
  $retval = array(
    'errno'  => TIMELINE_OK,
    'errmsg' => ''
  );

  $maxsize = variable_get('timeline_max_image_size', 1000000);

  // Version 4.x supported
  $handle = curl_init($url);

  if ($handle === FALSE)
  {
      return array('errno' => TIMELINE_NO_CONNECTION);
  }
  else {
    // ToDo: munge the filename because of security
    $tempnam = file_create_filename(basename($url), 'public://');
    $fh = fopen(drupal_realpath($tempnam), 'w');

    curl_setopt($handle, CURLOPT_FAILONERROR, TRUE);  // this works
    curl_setopt($handle, CURLOPT_HTTPHEADER, array("User-Agent: Timeline Download Script; See http://tiva.geo.uzh.ch;") );
    curl_setopt($handle, CURLOPT_FILE, $fh);
    curl_setopt($handle, CURLOPT_TIMEOUT, 30); // Set a timeout (for the whole operation)
    curl_setopt($handle, CURLOPT_RANGE,"-$maxsize"); // Limit the maximum file size

    curl_exec($handle);
    $info = curl_getinfo($handle, CURLINFO_CONTENT_TYPE);
    $httpcode = curl_getinfo($handle, CURLINFO_HTTP_CODE);
    curl_close($handle);
    fclose($fh);

    $file = new stdClass();
    $file->uri      = $tempnam;
    $file->filename = basename($file->uri);
    $file->filemime = file_get_mimetype($file->uri);
    $file->uid      = $user->uid;

    // The file is saved with status = 0. That means it is a temporary file and
    // will be deleted after a certain time. That's okay for preview, but in case
    // of a download we need to set status to 1 to get the system to keep it.
    file_save($file);

    $retval['httpcode'] = $httpcode;
    $retval['file']     = $file;
  }

  return $retval;
}

/*
 *
 */

function _timeline_save_image($sched_time) {
  db_insert('records')
    ->fields(array(
      'nid' => $archive,
      'fid' => $fid,
      'scheduled_time' => $sched_time,
      'saved_time' => '',
      'error' => $error,
      ))
    ->execute();
}




























/*
 * Implement hook_cron
 */

function timeline_cron() {
  // get the timestamp when cron was started
  $timestamp = system ('date -d "`ps -p ' . getmypid() . ' -o lstart=`" +\'%s\'');

  watchdog ('info', "timeline cron run (timestamp: $timestamp)");

  // load all archives
  $nids = db_select('node', 'n')
    ->fields('n', array('nid', 'created'))
    ->condition('status', 1)
    ->condition('type', 'archive')
    ->execute()
    ->fetchCol();

  $archives = node_load_multiple($nids);

  $max_processes = 10;
  $running_processes = 0;

  if (!function_exists('pcntl_fork')) {
    watchdog('warning', "Function pcntl_fork doesn't exist. Downloading images as batch job. Please run from cli with pcntl enabled to run parallel jobs. scripts/drupal.sh http://[your site]/cron.php");
  }

  // start a seperate process for each archive
  foreach ($archives as $archive) {
    if (!function_exists('pcntl_fork')) {
      _timeline_download_image($archive->archive_url['und'][0]['value']);
    } else {
      // If we close the connection, a new one will be made for the child and
      // it's not going to kill a connection that is in use just in the very
      // same moment...
      // Maybe persistent connections would be a way to circumvent that.
      // If you like, go ahead and have a try
      Database::closeConnection();

      $pid = pcntl_fork();

      if ($pid == -1) {
           // could not fork
      } else if ($pid) {
        // we are the parent => babysit the childs
        $running_processes++;
        if (count($running_processes) >= $max_processes) {
          $die_pid = pcntl_wait($status); // Wait for a child to exit
          $running_processes --;
        }
      } else {
        // we are the child => download image and exit the process to let the
        // parent spawn more processes
        $image = _timeline_download_image($archive->archive_url['und'][0]['value']);

        if ($image['errno'] == TIMELINE_OK) {
          $file = file_save_upload($image['filename']);
          $file->status = FILE_STATUS_PERMANENT;
          file_save($file);
        }

        exit;
      }
    }
  }
}















/*
 * Here follow the definitions for our URL-Field.
 * We have to do this to perform ajax. No idea why.
 *
 */

function timeline_field_widget_info() {
  return array(
    'text_timeline_url' => array(
      'label' => t('Source URL'),
      'field types' => array('text'),
      'settings' => array('size' => 60),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
        'default value' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
  );
}


function timeline_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $element += array(
    '#type'          => 'textfield',
    '#default_value' => isset($items[$delta]) ? $items[$delta] : '',
    '#ajax'          => array(
        'callback'     => '_ajax_check_url_callback',
        'wrapper'      => 'url-check-div',
        'method'       => 'replace',
        'effect'       => 'fade',
      ),
    '#suffix'        => '<div id="url-check-div"></div>',
  );
  return $element;
}

/**
 * Check that the filename ends with an allowed extension.
 * Copied from modules/file/file.inc
 *
 * @param $filename
 *   A filename to check.
 * @param $extensions
 *   A string with a space separated list of allowed extensions.
 *
 * @return
 *   An array. If the file extension is not allowed, it will contain an error
 *   message.
 *
 * @see hook_file_validate()
 */
function timeline_validate_extensions($filename, $extensions) {
  $errors = array();

  $regex = '/\.(' . preg_replace('/ +/', '|', preg_quote($extensions)) . ')$/i';
  if (!preg_match($regex, $filename)) {
    $errors[] = t('Only files with the following extensions are allowed: %files-allowed.', array('%files-allowed' => $extensions));
  }
  return $errors;
}